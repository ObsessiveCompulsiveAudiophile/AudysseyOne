<!-- 
  Copyright (c) [2024] [OCA - https://www.youtube.com/@OCAudiophile]

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, and to permit persons to
  whom the Software is furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

  Redistribution and use in source and binary forms, with or without
  modification, are not permitted for commercial purposes without the explicit
  permission of the author.
-->
<!DOCTYPE html><html>
<head>
  <title>Audyssey One - OCA 2024</title>
  <style>
    body {font-family: Arial, sans-serif;background-color: #f2f2f2;}
    .container {max-width: 1080px;margin: 0 auto;padding: 20px;}
    h2 {
      text-align: center;
      font-size: 24px;
      margin-bottom: 20px;
      color: #fff;
      background-color: #6fa3e7;
      padding: 10px 20px;
      border-radius: 10px;
    }
    strong {font-style: italic;}
    ol {padding-left: 20px;}
    .button-container {display: flex;justify-content: flex-start;margin-bottom: 20px;}
    button {
      padding: 12px 24px;
      font-size: 16px;
      border-radius: 30px;
      border: none;
      color: #fff;
      background-color: #6fa3e7;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      transition: all 0.3s ease;
      cursor: pointer;
      width: 200px;
    }
      button:hover {background-color: #4c6cb3;}
      button:disabled {opacity: 0.5;cursor: not-allowed;}
    #fileInput {display: none;}
    #logContainer {
      background-color: #333;
      color: #fff;
      padding: 10px;
      border-radius: 5px;
      max-height: 400px; /* Adjust the height as needed */
      overflow-y: auto; /* Add scrollbar if log exceeds max-height */
    }
    h2.log-heading {
      font-family: Arial, sans-serif;
      font-size: 16px; /* Adjust the font size as needed */
      text-indent: 5px; /* Adjust the left indent value as needed */
      margin-bottom: 5px; /* Adjust the bottom margin as needed */
      width: 120px;
      background-color: #808080;
      color: #fff;
    }
  </style>
</head>
<body>
<div class="container">
    <h2><strong>1-click</strong> Audyssey Optimization</h2>
    <ol>
      <li>Download the latest REW beta version (v5.40 Beta 18 or above) from <a href="https://www.avnirvana.com/threads/rew-api-beta-releases.12981/" target="_blank">here</a>.</li>
      <li>Remove any existing microphone calibration file from REW (Navigate to Preferences, then go to the "Cal files" tab).</li>
      <li>Under Preferences, set REW's "Maximum measurements" to 300 (This requires restarting REW).</li>
      <li>Click the "Upload" button below to select and save the Audyssey calibration file (extension: '.ady') transferred from your MultEQ Editor app.</li>
    </ol>
    <input type="file" id="fileInput" accept=".ady" onchange="handle_adyUpload(event)">
    <div class="button-container">
      <button id="button1" onclick="document.getElementById('fileInput').click()">Upload</button>
    </div>
    <ol start="5">
      <li>When prompted, save the target curve file "DrTooleTargetCurve.txt" and the zipped measurements file in a folder on your computer.</li>
      <li>In REW, navigate to the "EQ" tab, then House Curve, and select "DrTooleTargetCurve.txt" you saved earlier.</li>
      <li>Open the zip file (no need to extract it), select all files (CTRL+A for Windows, command+C for Mac), and drag and drop them onto REW.</li>
      <li>All Audyssey measurements will be automatically imported in the correct order; do not change their orders or names.</li>
      <li>Start the REW API server (Under Preferences, navigate to API).</li>
      <li>For better performance, keep REW on "SPL & Phase" tab, untick "Animate measurement list" in Preferences/View and close all REW child windows.</li>
    </ol>
    <div class="button-container">
      <button id="button2" onclick="startButton_clicked()" disabled>Start Optimization</button>
    </div>
    <br>
    <h2 class="log-heading">System Log:</h2>
        <pre id="logContainer"></pre>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.6.0/jszip.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.0/math.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
<script>
// **************************** version 1.1 18 MAR 2024 - 21:25 CET ************************************
  let adyContents; let fileName;
  let dChannels; let subtrueMaxDelay;let subtrueMaxTrim;
  let indexSW; let cDist;
  let sOs;
  let delay = 200; //increase this value if your machine is slow and needs more time to process operations
  const baseUrl = 'http://localhost:4735/measurements';
  const pollUrl = 'http://localhost:4735/measurements/process-result';
  let averageLvl;

  function checkModelSpeedOfSound(jsonData) {
    const targetModelName = jsonData.targetModelName;
    const lastSixDigits = targetModelName.slice(-6);
    const specialModels = [

                    //Add your model name in the list below if you're certain your receiver's speed of sound setting is 300 m/s.

                    "X1300W", "X2300W", "X3300W", "X4300H", "X6300H",
                    "X1400H", "X2400H", "X3400H", "X4400H", "X6400H",
                    "X1500H", "X2500H", "X3500H", "X4500H", "X6500H", "X8500H",
                    "X1600H", "X2600H", "X3600H",
                    "X1700H", "X2700H", "X3700H", "X4700H","X6700H",

                    "SR5011", "SR6011", "SR7011",
                    "SR5012", "SR6012", "SR7012", "SR8012",
                    "SR5013", "SR6013", "SR7013",
                    "SR5014", "SR6014", 
                    "SR5015", "SR6015", "SR7015", "SR8015",
                    "AV7703", "AV7704", "AV7705", "AV7706", "AV8805",
                    "NR1607", "NR1608", "NR1711"

                    ];

    const isSpecialModel = specialModels.includes(lastSixDigits);
    (isSpecialModel ? sOs = 300.0 : sOs = 343.0);
    return targetModelName;
  }
  async function updateConstants(jsonData) {
    let nSubs = 0;
    const channelKeys = Object.keys(jsonData.detectedChannels);
    dChannels = channelKeys.length;
    for (let i = dChannels; i >= 1; i--) {
      const key = channelKeys[i - 1];
      const commandId = jsonData.detectedChannels[key].commandId;
      if (commandId.startsWith("SW")) {
        nSubs++;
      } else {
        dChannels -= nSubs; dChannels++; break;
      }
    }
    if (nSubs === 0) {throw new Error('Optimization will not work with systems with NO subwoofer!')}
    subtrueMaxDelay = 0.0;
    subtrueMaxTrim = 0.0;
    if (nSubs > 1) {
        for (let i = dChannels - 1; i < Object.keys(jsonData.detectedChannels).length; i++) {
                const delayAdjustment = parseFloat(jsonData.detectedChannels[i].delayAdjustment);
                const trimAdjustment = parseFloat(jsonData.detectedChannels[i].trimAdjustment);
                if (delayAdjustment > subtrueMaxDelay) {subtrueMaxDelay = delayAdjustment;}
                if (trimAdjustment < subtrueMaxTrim) {subtrueMaxTrim = trimAdjustment;}
              }
    }
    subtrueMaxDelay = 6.0 - subtrueMaxDelay;
    subtrueMaxTrim = -(12.0 + subtrueMaxTrim) / 2;
    cDist = parseFloat(jsonData.detectedChannels[1].customDistance);
    if (!cDist > 0.0) {cDist = parseFloat(jsonData.detectedChannels[1].channelReport.distance);}

        if (cDist === 0) {
          const result = await swal.fire({
            confirmButtonColor: "#6fa3e7",
            text: "Audyssey was not able to set your speaker distances due to excessive subwoofer delay. Please enter the actual distance of your center speaker to your main listening position (in meters) to proceed with the optimization:",
            input: 'text',
            showCancelButton: true
          });

            if (result.isConfirmed) {
              const userInput = result.value;
              cDist = parseFloat(userInput);
              console.info(`Center speaker actual distance is set at ${cDist}m based on user input.`);
            }
          
    } 
  }
  function handle_adyUpload(event) {
    document.getElementById("button2").disabled = false;
    const file = event.target.files[0];
    const reader = new FileReader();
    reader.onload = function(e) {
      adyContents = e.target.result;
      const jsonData = JSON.parse(adyContents);
      const zip = new JSZip();
      for (const key in jsonData.detectedChannels) {
        if (jsonData.detectedChannels.hasOwnProperty(key)) {
          const responseData = jsonData.detectedChannels[key].responseData;
          for (const arrayKey in responseData) {
            if (responseData.hasOwnProperty(arrayKey)) {
             const arrayData = responseData[arrayKey].join('\n');
              const rewHeader = "* Impulse Response data saved by REW\n0 // Peak value before normalisation\n0 // Peak index\n16384 // Response length\n2.0833333333333333E-5 // Sample interval (seconds)\n0.0 // Start time (seconds)\n* Data start\n" + arrayData;
              var measurementName = jsonData.detectedChannels[key].commandId + arrayKey + '.txt';
              zip.file(measurementName, rewHeader);
            }
          }
        }
      }
      zip.generateAsync({type: "blob"}).then(function (content) {
        const urlZip = URL.createObjectURL(content);
        var downloadLink = document.createElement("a");
        downloadLink.href = urlZip;
        fileName = file.name;
        downloadLink.download = getadyName(file.name, "_extractedMeasurements.zip");
        downloadLink.style.display = "none";
        document.body.appendChild(downloadLink);
        downloadLink.click();
        document.body.removeChild(downloadLink);
      });
      const targetCurve = `
6.00 5.197,
6.30 5.197,
6.70 5.197,
7.10 5.197,
7.50 5.197,
8.00 5.197,
8.50 5.197,
9.00 5.197,
9.50 5.197,
10.00 5.197,
10.60 5.197,
11.20 5.197,
11.80 5.197,
12.50 5.197,
13.20 5.197,
14.00 5.197,
15.00 5.197,
16.00 5.197,
17.00 5.197,
18.00 5.196,
19.00 5.196,
20.00 5.196,
21.20 5.196,
22.40 5.196,
23.60 5.195,
25.00 5.193,
26.50 5.190,
28.00 5.185,
30.00 5.175,
31.50 5.166,
33.50 5.150,
35.50 5.131,
37.50 5.107,
40.00 5.073,
42.50 5.032,
45.00 4.985,
47.50 4.934,
50.00 4.877,
53.00 4.802,
56.00 4.722,
60.00 4.605,
63.00 4.512,
67.00 4.381,
71.00 4.245,
75.00 4.105,
80.00 3.926,
85.00 3.745,
90.00 3.565,
95.00 3.387,
100.00 3.212,
106.00 3.009,
112.00 2.813,
118.00 2.628,
125.00 2.427,
132.00 2.241,
140.00 2.048,
150.00 1.834,
160.00 1.648,
170.00 1.486,
180.00 1.346,
190.00 1.225,
200.00 1.120,
212.00 1.011,
224.00 0.919,
236.00 0.840,
250.00 0.760,
265.00 0.688,
280.00 0.626,
300.00 0.555,
315.00 0.509,
335.00 0.455,
355.00 0.406,
375.00 0.363,
400.00 0.314,
425.00 0.269,
450.00 0.227,
475.00 0.188,
500.00 0.152,
530.00 0.110,
560.00 0.071,
600.00 0.021,
630.00 -0.015,
670.00 -0.060,
710.00 -0.102,
750.00 -0.143,
800.00 -0.192,
850.00 -0.238,
900.00 -0.282,
950.00 -0.325,
1000.00 -0.365,
1060.00 -0.411,
1120.00 -0.455,
1180.00 -0.497,
1250.00 -0.544,
1320.00 -0.589,
1400.00 -0.637,
1500.00 -0.694,
1600.00 -0.746,
1700.00 -0.792,
1800.00 -0.833,
1900.00 -0.867,
2000.00 -0.894,
2120.00 -0.921,
2240.00 -0.944,
2360.00 -0.965,
2500.00 -0.988,
2650.00 -1.012,
2800.00 -1.034,
3000.00 -1.061,
3150.00 -1.080,
3350.00 -1.103,
3550.00 -1.125,
3750.00 -1.146,
4000.00 -1.173,
4250.00 -1.199,
4500.00 -1.227,
4750.00 -1.257,
5000.00 -1.289,
5300.00 -1.330,
5600.00 -1.369,
6000.00 -1.420,
6300.00 -1.456,
6700.00 -1.502,
7100.00 -1.544,
7500.00 -1.583,
8000.00 -1.626,
8500.00 -1.664,
9000.00 -1.695,
9500.00 -1.719,
10000.00 -1.740,
10600.00 -1.761,
11200.00 -1.777,
11800.00 -1.792,
12500.00 -1.806,
13200.00 -1.819,
14000.00 -1.832,
15000.00 -1.845,
16000.00 -1.857,
17000.00 -1.866,
18000.00 -1.873,
19000.00 -1.879,
20000.00 -1.884,
21200.00 -1.890,
22400.00 -1.895,
23600.00 -1.898`;
      const blob = new Blob([targetCurve], {type: 'text/plain'});
      const urlBlob = URL.createObjectURL(blob);
      var downloadLink = document.createElement("a");
      downloadLink.href = urlBlob;
      downloadLink.download = "DrTooleTargetCurve.txt"; 
      downloadLink.style.display = "none";
      document.body.appendChild(downloadLink);
      downloadLink.click();
      document.body.removeChild(downloadLink);
    };
    reader.readAsText(file);
  }
  function getadyName(fileName, suffix) {
    var dotIndex = fileName.lastIndexOf(".");
    var modifiedName = fileName.substring(0, dotIndex) + suffix;
  return modifiedName;
  }
  function startButton_clicked() {
    document.getElementById('button1').disabled = true;
    optimizerOCA();
  }
  async function fetch_mREW(indice = null, method = 'GET', _body = null){
      let body;
      let requestUrl;
      if (indice === null) {requestUrl = baseUrl;} else {requestUrl = baseUrl + `/${indice}`};
      if (method === 'PUT') {body = _body}
      while(true) {
          try {
              const response = await fetch(requestUrl,{
                method: method,
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(body)
                });
              if (!response.ok) {
                  await new Promise(resolve => setTimeout(resolve, delay)); 
                  } else {const data = await response.json();
                          return data;}
                   
          } catch (error) { 
              console.error('Error fetching result:', error);
              }
      }
  }
  async function postNext(processName, indices, parameters = null) {
      let requestUrl; let body;
      if (Array.isArray(indices)) {requestUrl = `${baseUrl}/process-measurements`}
          else {(parameters === null ? requestUrl = `${baseUrl}/${indices}/eq/command` : requestUrl = `${baseUrl}/${indices}/command`)};
      if (requestUrl.endsWith('/command')) {body = {command: processName}}
          else body = {processName: processName};
      if (parameters != null) {body = { ...body, parameters: parameters}};
      if (Array.isArray(indices)) {body = { ...body, measurementIndices: indices}};
          await fetch(requestUrl, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(body)
          });
      const object = await pollComplete(processName);
      return object;
  }
  async function pollComplete(processName) {
      while(true) {
          try {
              const response = await fetch(pollUrl);
              if (!response.ok) {
                  throw new Error('Network response was not OK!');
                  }
              const data = await response.json();
              if (data.message === "Completed" && data.processName === processName) {
                  return data;
                  } else {
                      await new Promise(resolve => setTimeout(resolve, delay)); 
                      }
          } catch (error) { 
              console.error('Error fetching result:', error);
              }
      }
  }
  async function postSafe(requestUrl, parameters) {
      while(true) {
          try {
              const response = await fetch(requestUrl,{
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(parameters)
              });
              if (!response.ok) {
                  throw new Error('Network response was not OK!');
                  }
              const data = await response.json();
              if (data.message === "Update processed") {
                  return data;
                  } else {
                      await new Promise(resolve => setTimeout(resolve, delay)); 
                      }
          } catch (error) { 
              console.error('Error fetching result:', error);
              }
      }
  }
  async function postDelete(indice) {
      const mDeleted = `Measurement ${indice} deleted`
      while(true) {
          try {
              const response = await fetch(`${baseUrl}/${indice}`,{
                method: 'DELETE',
                headers: {'Content-Type': 'application/json'},
                });
              if (!response.ok) {
                   throw new Error('Network response was not OK!');
                  }
              const data = await response.json();
              if (data.message === mDeleted) {
                  return indice;
                  } else {
                      await new Promise(resolve => setTimeout(resolve, delay)); 
                      //delay--;
                      }
          } catch (error) { 
              console.error('Error fetching result:', error);
              //delay++;
              await new Promise(resolve => setTimeout(resolve, delay)); 
              }
      }
  }
  async function fetchSafe(extUrl, indice, parameters = null) {
    const requestUrl = `${baseUrl}/${indice}/${extUrl}`;
    let options;
    if (parameters === null) {
      options = {
        method: 'GET'
      };
    } else {
      options = {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(parameters)
      };
    }
    while (true) {
      try {
        const response = await fetch(requestUrl, options);
        if (!response.ok) {
          await new Promise(resolve => setTimeout(resolve, delay));
        } else {
          const data = await response.json();
          return data;
        }
      } catch (error) {
        console.error('Error fetching result:', error);
      }
    }
  }
  async function check_initialConditions() {
    
    const measurements = await fetch_mREW();
    const titles = {};
    let titleIndices = {};
    const mCount = Object.keys(measurements).length
    for (let i = 1; i <= mCount; i++) {
      const title = measurements[i].title;
      const titleKey = title.replace(/\d+/g, '');
      if (!/^\D+(\d+)?$/.test(titleKey)) {
        throw new Error(`Speaker name ${titleKey} does not end with an indice.`);
      }
      if (!titles[titleKey]) {
        titles[titleKey] = true;
        titleIndices[titleKey] = [];
      }
      const matchResult = title.match(/\d+/);
      if (matchResult && matchResult.length > 0) {
        titleIndices[titleKey].push(parseInt(matchResult[0]));
      } else {
        throw new Error(`No indices found in speaker name: ${title}`);
      }
    }
    nSpeakers = Object.keys(titles).length;
    const indicesCounts = Object.values(titleIndices).map(indices => indices.length);
    const isIndicesEqual = indicesCounts.every(count => count === indicesCounts[0]);
    if (!isIndicesEqual) {
      throw new Error('Speaker names have different numbers of indices.');
    }
    for (const titleKey in titleIndices) {
      const indices = titleIndices[titleKey];
      const sortedIndices = [...indices].sort((a, b) => a - b);
      if (JSON.stringify(indices) !== JSON.stringify(sortedIndices)) {
        throw new Error(`Indices of ${titleKey} are not in order.`);
      }
    }
    const tcResponse = await fetch('http://localhost:4735/eq/house-curve');
    if (tcResponse.ok) {
      const tcPath = await tcResponse.json();
      if (tcPath && tcPath.message) {
        console.log(`Applying Target Curve located @ ${tcPath.message}`);
      } else {
        throw new Error('Failed to locate target curve! Browse to and select "DrTooleTargetCurve.txt" in "REW / EQ window / House curve.');
      }
    } else {
      throw new Error(`Failed to fetch target curve, please start the API server! HTTP status code: ${tcResponse.status}.`);
    }
    return (nSpeakers);
  }
  async function getVectorAverages() {
    const measurements = await fetch_mREW();
    const mCount = Object.keys(measurements).length
    const micPositions = mCount / dChannels;
    console.log(`Transposing measurements from ${micPositions} different microphone positions to the primary listening position...`);
    for (let i = 1; i <= mCount; i+= micPositions) {
      const indices = Array.from({length: micPositions}, (_, j) => i + j);
      await postNext('Cross corr align', indices);
      await postNext('Vector average', indices);
      const tIndex = mCount + 1 + (i - 1) / micPositions;
      const newTitle = measurements[i].title.slice(0,-1) + "o";
      await fetch_mREW(tIndex, 'PUT', {title: newTitle});
    };
    console.info(`Done!`);
    console.info(`************************************************************************************************************************`);
    console.info(`Cleaning up processed measurements...`);
    for (let i = mCount; i > 0; i--) {
      await postDelete(i);
      await new Promise(resolve => setTimeout(resolve, delay * 1.15)); }
      console.log(`Done!`);
      console.info(`************************************************************************************************************************`);
  }
  async function alignLevels() {
    let customLevel = new Array(dChannels + 1).fill(0);
    let targetSum = 0;
    let target = {};
    let title = {};
    indexSW = 1;
    console.log('Calculating precise speaker volume levels...');
    for (let i = 1; i <= dChannels; i++) {
      await postNext('Add SPL offset', i, {offset: -42});
      const mData = await fetch_mREW(i);
      title[i] = mData.title;
      await postSafe(`${baseUrl}/${i}/target-settings`, { shape: "None" });
      await postSafe(`${baseUrl}/${i}/room-curve-settings`, { addRoomCurve: false });
      if (title[i].startsWith("SW")) {indexSW = i; continue;}
      await postNext('Smooth', i, {smoothing: "1/1"});
      await postNext('Calculate target level', i);
      await postNext('Smooth', i, {smoothing: "None"});
      const targetResponse = await fetchSafe('target-level',i);
      target[i]= parseFloat(targetResponse);
      console.log(`${title[i]}: ${target[i]} dB`);
      targetSum += target[i];
    }
    averageLvl = parseFloat(targetSum / (dChannels - 1.0));
    console.info(`Optimized target volume level for all speakers: ${averageLvl} dB`);
    console.info(`Total number of speakers averaged (excludes subwoofer): ${dChannels - 1}`);
    console.log('Finalized speaker volume settings:');
    for (let i = 1; i <= dChannels; i++) {
      if (i === indexSW) {
        console.info(`Optimizing subwoofer volume adjustment...`);
        await fetchSafe('target-level',i, averageLvl);
        await postNext('Generate target measurement', indexSW);
        const indexTC = dChannels + 1;
        const volShift = await postNext('Align SPL', [indexSW, indexTC], {"frequencyHz": "63","spanOctaves": "3","targetdB": "average"});
        const volDelta = parseFloat(volShift.results[indexSW].alignSPLOffsetdB);
        let volDeltaNew = volDelta;
        if ((volDelta > 6.0) || (volDelta < subtrueMaxTrim)) {
          console.error(`Required subwoofer volume adjustment is beyond AV Receiver's hardware limits!`);
          console.warn(`Be advised to repeat Audyssey calibration process after re-adjusting subwoofer volume!`);
          console.info(`The algorithm will now apply maximum possible volume setting to the subwoofer and continue.`);
          console.warn("However, optimization will not result in the best achiveable performance!");
          volDeltaNew = Math.max(subtrueMaxTrim, Math.min(12, volDelta));
        }
        customLevel[i] = (Math.round(volDeltaNew * 4) / 2).toFixed(1);
        console.log(`${title[indexSW].slice(0,-1)}: ${customLevel[i]} dB ; with ${volDeltaNew * 2 - customLevel[i]} dB filter compensation`);
        await postNext('Add SPL offset', indexSW, {offset: volDeltaNew});
        await postNext('Add SPL offset', indexTC, {offset: volDeltaNew});
        continue;
      }
    const volDif = parseFloat(averageLvl - target[i]);
    let volDifNew = volDif;
    if ((volDif > 12.0) || (volDif < -12.0)) {
      console.error(`${title[i].slice(0,-1)} seems to require volume adjustment beyond AV Receiver's hardware limits!`);
      console.warn(`Be advised to find the root cause of this problem and repeat Audyssey calibration if possible!`);
      console.info(`Optimization will now apply maximum possible volume setting to ${title[i].slice(0,-1)} and continue.`);
      console.warn("However, the optimization 'may' not result in the best achiveable performance!");
      volDifNew = Math.max(-12, Math.min(12, volDif));
    }
    customLevel[i] = (Math.round(volDifNew * 2) / 2).toFixed(1);
    console.log(`${title[i].slice(0,-1)}: ${customLevel[i]} ; with ${volDifNew - customLevel[i]} dB filter compensation`)
    await postNext('Add SPL offset', i, {offset: customLevel[i]});
    }
    console.info(`************************************************************************************************************************`);
    return customLevel;
  }
  async function alignDelays() {
  console.info('Deriving optimal speaker distances with advanced cross-correlation analysis...');
  let customDistance = new Array(dChannels + 1).fill(0);
  const minDelay = parseFloat(6.0 / sOs);
  let mDist = {};
  let mSec = {};
  var minSec = cDist / sOs;
  const indices = Array.from({ length: dChannels }, (_, index) => index + 1);
  const mDelay = await postNext('Cross corr align', indices);
  const measurements = await fetch_mREW();
  for (let i = 1; i <= dChannels; i++) {
    mSec[i] = parseFloat(mDelay.results[i][`Adjustment (seconds)`]);
    customDistance[i] = Number((cDist + (mSec[i] * sOs)).toFixed(2));
    if (mSec[i] < minSec) {
      minSec = mSec[i];
    }
    console.log(`${measurements[i].title.slice(0, -1)}: ${customDistance[i]}m`);
  }
  let minChk_val = (parseFloat(mSec[indexSW]) - minSec - mSec[1]) * sOs;
  let minChk = Number(minChk_val.toFixed(2));
  let finDist_val = cDist + minSec * sOs + minChk;
  customDistance[indexSW] = Number(finDist_val.toFixed(2));
  if (minChk <= subtrueMaxDelay) {
    console.info(`Subwoofer distance is 'optimally' set @ ${customDistance[indexSW]}m and is 'safely' within the AV Receiver's speaker spacing limits.`);
  } else {
    console.warn(`Calculated optimal subwoofer distance of ${customDistance[indexSW]}m exceeds AV Receiver's max. speaker spacing limit [${minChk}m vs ${subtrueMaxDelay.toFixed(2)}m]!`);
    console.info('Attempting to re-align the sub...');
    await postNext('Remove IR delays', [1, indexSW]);
    await postNext('Remove IR delays', [1, indexSW]);
    await postNext('Remove IR delays', [1, indexSW]);
    const resultC = await fetch_mREW(1);
    const resultSW = await fetch_mREW(indexSW);
    mSec[1] = parseFloat(resultC.cumulativeIRShiftSeconds);
    mSec[indexSW] = parseFloat(resultSW.cumulativeIRShiftSeconds);
    minChk_val = (parseFloat(mSec[indexSW]) - minSec - mSec[1]) * sOs;
    minChk = Number(minChk_val.toFixed(2));
    finDist_val = cDist + minSec * sOs + minChk;
    customDistance[indexSW] = Number(finDist_val.toFixed(2));
    if (minChk <= subtrueMaxDelay) {
      console.info(`Subwoofer distance is re-set to ${customDistance[indexSW]}m and is now within receiver speaker spacing limits [${minChk}m vs ${subtrueMaxDelay.toFixed(2)}m].`);
    } else {
      console.warn(`Recalculated subwoofer distance of ${customDistance[indexSW]}m still exceeds AV Receiver's max. speaker spacing limit [${minChk}m vs ${subtrueMaxDelay.toFixed(2)}m]!`);
      console.info('Attempting to re-align the sub...');
      await postNext('Align IR start', [1, indexSW]);
      await postNext('Align IR start', [1, indexSW]);
      const resultC = await fetch_mREW(1);
      const resultSW = await fetch_mREW(indexSW);
      mSec[1] = parseFloat(resultC.cumulativeIRShiftSeconds);
      mSec[indexSW] = parseFloat(resultSW.cumulativeIRShiftSeconds);
      minChk_val = (parseFloat(mSec[indexSW]) - minSec - mSec[1]) * sOs;
      minChk = Number(minChk_val.toFixed(2));
      finDist_val = cDist + minSec * sOs + minChk;
      customDistance[indexSW] = Number(finDist_val.toFixed(2));
      if (minChk <= subtrueMaxDelay) {
        console.info(`Subwoofer distance is again re-set to ${customDistance[indexSW]}m and is finally within the receiver speaker spacing limits [${minChk}m vs ${subtrueMaxDelay.toFixed(2)}m].`);
      } else {
        console.warn(`Recalculated subwoofer distance of ${customDistance[indexSW]}m still exceeds AV Receiver's max. speaker spacing limit [${minChk}m vs ${subtrueMaxDelay.toFixed(2)}m]!`);
        customDistance[indexSW] = Number((subtrueMaxDelay + cDist + minSec * sOs).toFixed(2));
        console.info(`Setting subwoofer distance 'suboptimally' to ${customDistance[indexSW]}m (max. allowed).`);
        console.warn("Please ensure to inspect your setup thoroughly to identify the root cause of the significant delay!")
      }
    }
  }
  console.info(`************************************************************************************************************************`);
  return customDistance;
  }
  async function generateFilters() {
    console.info(`Crafting custom room correction filters...`);
    delay *= 1.75;
    const measurements = await fetch_mREW();
    let indexTC = dChannels + 1;
    await postNext('Minimum phase version', indexTC, {
      "include cal": false,
      "append lf tail": false, 
      "append hf tail": false,
      "frequency warping": false,
      "replicate data": false
    });
    await postDelete(indexTC);
    await fetch_mREW(indexTC,'PUT', {title: "Dr Toole target curve"});
    await new Promise(resolve => setTimeout(resolve, delay * 1.15));
    for (let i = 1; i <= dChannels; i++) {
      await postNext('Minimum phase version', i, {
        "include cal": false,
        "append lf tail": false, 
        "append hf tail": false,
        "frequency warping": false,
        "replicate data": false
      });
      ii = dChannels + i * 5 - 3;
      
      await postNext('Arithmetic', [ii, indexTC], {
        function: "A / B",
        regularisation: "0",
        lowerLimit: "0",
        upperLimit: "0"});
      await postNext('Arithmetic', [ii + 1, ii + 1], {
        function: "1 / A",
        maxGain: "3",
        lowerLimit: "0",
        upperLimit: "750",
        autoTarget: "0",
        excludeNotches: false});
      await postNext('Minimum phase version', ii + 2, {
        "include cal": false,
        "append lf tail": false, 
        "append hf tail": false,
        "frequency warping": false,
        "replicate data": false
      });
      await postNext('Arithmetic', [i, ii + 3], {function: "A * B"});
      const finTitle = measurements[i].title.replace("o","final");
      await fetch_mREW(ii + 4, 'PUT', {title: finTitle});
      const filtTitle = measurements[i].title.replace("o","");
      await fetch_mREW(ii + 3, 'PUT', {title: filtTitle});
    }
    console.log(`Done!`);
    console.info(`************************************************************************************************************************`);
  }
  async function calculateCrossovers() {
    console.info(`Pinpointing crossover frequencies for each speaker...`);
    let customCrossover = new Array(dChannels + 1).fill(0);
    let newMeasurements;
    delay *= 3.0;
    const level = averageLvl;
    const measurements = await fetch_mREW();
    const indexSWf = dChannels + indexSW * 5 + 1;
    const start = dChannels + 6;
    const end = dChannels * 6 + 1;
    for (let i = start; i <= end; i += 5) {
      if (i === indexSWf) {continue;}
      await postNext('Cross corr align', [indexSWf, i]);
      await postNext('Vector average', [indexSWf, i]);
      const newTitle = measurements[i].title.slice(0,-5) + "xo";
      newMeasurements = await fetch_mREW();
      const newIndex = Object.keys(newMeasurements).length;
      await fetch_mREW(newIndex, 'PUT', {title: newTitle});
        }
      newMeasurements = await fetch_mREW();
      let k=1;
      for (let i = (end + 1); i <= (end + dChannels - 1); i++) {
        const magBase64 = await fetchSafe('frequency-response', i);
        const bytes = Uint8Array.from(atob(magBase64.magnitude), c => c.charCodeAt(0));
        const buffer = bytes.buffer;
        const floatArray = new Float32Array(buffer);
        const dataView = new DataView(buffer);  
        const arr = [];
        const fixedValues = [80, 90, 100, 110];
        let maxSplValue = -Infinity;
        let maxSplValueIndex = -1;
        for (let j = 0; j < 442; j++) {
          const splValue = dataView.getFloat32(j * 4);
          arr.push(splValue);
          if (splValue > maxSplValue) {
            maxSplValue = splValue;
            maxSplValueIndex = j;
          }
        }
        const xoFreq = maxSplValueIndex * 0.366211 + 2.929688;
        let roundedXoFreq;
        let minDiff = Infinity;
        for (const value of fixedValues) {
          const diff = Math.abs(xoFreq - value);
          if (diff < minDiff) {
            minDiff = diff;
            roundedXoFreq = value;
          }
        }
        console.log(`Calculated optimal crossover frequency between ${newMeasurements[i].title.slice(0,-2)} and the subwoofer: ${xoFreq}Hz, nearest match in the unit: ${roundedXoFreq}Hz`)
        if (k === indexSW) {k++;}
        customCrossover[k] = String(roundedXoFreq).slice(0, 2);
        k++;
      }
      console.info(`Done!`);
      console.info(`Speaker pairs with different crossover frequencies will be synched at the 'lower one' of the two in the AV Receiver.`);
      console.info(`This algorithm will NOT assign any speaker as 'Full Range' to keep the overall bass response under subwoofer control.`);
      console.info(`Feel free to experiment with system bass response by switching some or all of your truly full range speakers to "Large".`);
      console.info(`Increasing crossover frequencies 'may' lead to audible improvements due to decreased loads on the AVR and the speakers.`);
      console.info(`Determined XO frequencies will work best with properly aligned subwoofers. Make all efforts to decrease SW delays.`);
      console.info(`************************************************************************************************************************`);
    return customCrossover;  
  }
  async function updateADY(customLevel, customDistance, customCrossover){
    console.info(`Consolidating all optimal adjustments into the final calibration file...`);
    console.info(`************************************************************************************************************************`);
    let filterTitle = {};
    const jsonData = JSON.parse(adyContents);
    jsonData.dynamicVolume=false;
    jsonData.lfc=false;
    jsonData.dynamicEq=false;
    jsonData.enTargetCurveType = 1;

    for (const key in jsonData.detectedChannels) {
      if (jsonData.detectedChannels.hasOwnProperty(key)) {
        const responseData = jsonData.detectedChannels[key].responseData;
        for (const arrayKey in responseData) {
          if (responseData.hasOwnProperty(arrayKey)) {
            const zerosArray = Array(16383).fill("0");
            zerosArray.unshift("1");
            responseData[arrayKey] = zerosArray;
          }
        }
      }
    }
    const start = dChannels + 5;
    const end = dChannels * 6;
    for (let i = start; i <= end; i += 5) {
      const mData = await fetch_mREW(i);
      filterTitle[i] = mData.title;
      const fetchedData = await fetchSafe('frequency-response',i);
      const magBase64 = fetchedData.magnitude;
      const startFreq = fetchedData.startFreq;
      const freqStep = fetchedData.freqStep;
      const bytes = Uint8Array.from(atob(magBase64), c => c.charCodeAt(0));
      const buffer = bytes.buffer;
      const floatArray = new Float32Array(buffer);
      const dataView = new DataView(buffer);
      for (let i = 0; i < floatArray.length; i++) {floatArray[i] = dataView.getFloat32(i * 4);}
      const firstColumn = new Float32Array(floatArray.length);
      for (let i = 0; i < firstColumn.length; i++) {firstColumn[i] = startFreq + i * freqStep;}
      const decodedData = new Array(floatArray.length);
      for (let i = 0; i < decodedData.length; i++) {decodedData[i] = [firstColumn[i], floatArray[i]];}
      const additionalRows = [ //anti HFR1
      [3000, 0.011],[3150, 0.016],[3350, 0.038],[3550, 0.057],[3750, 0.086],[4000, 0.139],[4250, 0.208],
      [4500, 0.288],[4750, 0.377],[5000, 0.473],[5300, 0.591],[5600, 0.710],[6000, 0.872],[6300, 0.993],
      [6700, 1.151],[7100, 1.307],[7500, 1.449],[8000, 1.587],[8500, 1.701],[9000, 1.802],[9500, 1.902],
      [10000, 2.005],[10600, 2.137],[11200, 2.303],[11800, 2.515],[12500, 2.810],[13200, 3.128],[14000, 3.518],
      [15000, 4.063],[16000, 4.735],[17000, 5.522],[18000, 6.281],[19000, 6.876],[20000, 7.225]];
      const combinedData = [...decodedData.slice(0, filterTitle[i].startsWith('SW') ? 2703 : 3249), ...additionalRows.filter(row => !filterTitle[i].startsWith('SW'))];
      const customTargetCurvePoints = combinedData.map(point => `{${point[0]}, ${point[1]}}`);
      const thisChannel = jsonData.detectedChannels.find(channel => channel.commandId === filterTitle[i]);
      thisChannel.customTargetCurvePoints = customTargetCurvePoints;
      if (!filterTitle[i].startsWith("SW")) {
        let j = (i - dChannels) / 5;
        thisChannel.midrangeCompensation = false;
        thisChannel.frequencyRangeRolloff = 20000;
        thisChannel.customLevel = Number(parseFloat(customLevel[j]).toFixed(2));
        thisChannel.customDistance = Number(parseFloat(customDistance[j]).toFixed(2));
        thisChannel.customCrossover = customCrossover[j];
        thisChannel.customSpeakerType = "S";
        thisChannel.channelReport.customEnSpeakerConnect = 1;
      }
    }
    for (let channel of jsonData.detectedChannels) {
      if (channel.commandId.startsWith("SW")) {
        let customDistanceValue = parseFloat(customDistance[indexSW]) + parseFloat(channel.delayAdjustment);
        let customLevelValue = parseFloat(customLevel[indexSW]) + parseFloat(channel.trimAdjustment);
        channel.customDistance = parseFloat(customDistanceValue);
        let distanceValue = parseFloat(customDistance[indexSW]);
        channel.channelReport.distance = parseFloat(distanceValue);
        channel.customLevel = parseFloat(customLevelValue);
        channel.frequencyRangeRolloff = 200;
        channel.trimAdjustment = "0.0";
        channel.delayAdjustment = "0.0";
      }
    }
    const cleanUp = await fetch_mREW();
    delay *= 0.4;
    for (let i = dChannels * 7; i > dChannels + 1; i --){
      const iDelete = cleanUp[i].title;
      if (iDelete.includes("-MP") || iDelete.includes("1/A") || iDelete.includes("over") || iDelete.includes("xo")) {
        await postDelete(i);
        await new Promise(resolve => setTimeout(resolve, delay * 1.15));
      }
    }
    const adyOCA = JSON.stringify(jsonData);
    const blob = new Blob([adyOCA], {type: 'json'});
    const urlBlob = URL.createObjectURL(blob);
    var downloadLink = document.createElement("a");
    downloadLink.href = urlBlob;
    downloadLink.download = getadyName(fileName, "_OneOptimized.ady");
    downloadLink.style.display = "none";
    downloadLink.style.display = "none";
    document.body.appendChild(downloadLink);
    downloadLink.click();
    document.body.removeChild(downloadLink);
  }
  async function optimizerOCA() {
    try {
      const jsonData = JSON.parse(adyContents);
      const tName = checkModelSpeedOfSound(jsonData);
      console.info(`Based on your specific AVR model: ${tName}, speed of sound has been set to ${sOs.toFixed(1)} m/s for all distance calculations.`);
      console.warn('(If you think this setting is incorrect, please notify OCA!)');
      console.info(`************************************************************************************************************************`);
      await updateConstants(jsonData);
      var nSpeakers = await check_initialConditions();
      console.info(`************************************************************************************************************************`);
      if (nSpeakers === dChannels) {console.info('Optimization process started...');} else {throw Error('Number of channels mismatch!');}
      await getVectorAverages();
      const customLevel = await alignLevels();
      const customDistance = await alignDelays();
      await generateFilters();
      const customCrossover = await calculateCrossovers();
      await updateADY(customLevel, customDistance, customCrossover);
      console.info(`************************************************************************************************************************`);
      console.log("'Audyssey One' optimization is completed with SUCCESS!");
      console.info(`************************************************************************************************************************`);
      console.info("When prompted, save the .ady file to your PC and send it 'as is' to your MultEQ Editor app.");
      console.info("Next, transfer it 'as is' from the app to your AV receiver as you normally would.");
      console.info("The Editor app graphs will no longer represent final speaker responses due to the special filtering technique implemented.");
      console.info("Speaker responses with 'final' indices under REW / All SPL tab are your expected post-calibration responses.");
      console.info(`************************************************************************************************************************`);
      console.info('YouTube video (https://youtu.be/iU1ZBsru76M) contains a download link for several Dolby Atmos & DTS-X test clips');
      console.info("compatible for playback via a USB key on your Blu-ray player for testing.");
      console.info(`************************************************************************************************************************`);
      console.info('Enjoy your new sound!');
    }
    catch (error) {
      console.error(error, "- program execution has stopped!");
    }
  }
  (function () {
    const logContainer = document.getElementById('logContainer');
    function scrollToBottom() {
      logContainer.scrollTop = logContainer.scrollHeight;
    }
    const originalWarn = console.warn;
    console.warn = function (...args) {
      const warningMessage = args.join(' ');
      const warningEntry = `${new Date().toLocaleTimeString()} [WARNING] ${warningMessage}\n`;
      logContainer.textContent += warningEntry;
      scrollToBottom();
      originalWarn.apply(console, args);
    };
    const originalInfo = console.info;
        console.info = function (...args) {
          const warningMessage = args.join(' ');
          const warningEntry = `${new Date().toLocaleTimeString()} [INFO] ${warningMessage}\n`;
          logContainer.textContent += warningEntry;
          scrollToBottom();
          originalWarn.apply(console, args);
        };
    const originalLog = console.log;
    console.log = function (...args) {
      const logMessage = args.join(' ');
      const logEntry = `${new Date().toLocaleTimeString()} [LOG] ${logMessage}\n`;
      logContainer.textContent += logEntry;
      scrollToBottom();
      originalLog.apply(console, args);
    };
    const originalError = console.error;
    console.error = function (...args) {
      const errorMessage = args.join(' ');
      const errorEntry = `${new Date().toLocaleTimeString()} [ERROR] ${errorMessage}\n`;
      logContainer.textContent += errorEntry;
      scrollToBottom();
      originalError.apply(console, args);
    };
  })();

</script>
</body></html>
